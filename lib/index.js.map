{"version":3,"file":"index.js","sources":["../node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js","../node_modules/unist-util-is/lib/index.js","../node_modules/unist-util-visit-parents/lib/color.js","../node_modules/unist-util-visit-parents/lib/index.js","../node_modules/mdast-util-find-and-replace/lib/index.js","../node_modules/mdast-util-newline-to-break/lib/index.js","../node_modules/remark-breaks/index.js","../src/index.js"],"sourcesContent":["export default function escapeStringRegexp(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when it’s always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @typedef {Record<string, unknown>} Props\n * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test\n *   Check for an arbitrary node, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if a node passes a test, unaware of TypeScript inferral.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean | void}\n *   Whether this node passes the test.\n */\n\n/**\n * @template {Node} Kind\n *   Node type.\n * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest\n *   Check for a node that can be inferred by TypeScript.\n */\n\n/**\n * Check if a node passes a certain test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback TestFunctionPredicate\n *   Complex test function for a node that can be inferred by TypeScript.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this node passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is a node, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if a node is a node and passes a certain node test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific node, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific node.\n * @param index\n *   The node’s position in its parent.\n * @param parent\n *   The node’s parent.\n * @returns\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  /**\n   * @type {(\n   *   (() => false) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &\n   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &\n   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function is(node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      // @ts-expect-error Looks like a node.\n      return node && node.type && typeof node.type === 'string'\n        ? Boolean(check.call(context, node, index, parent))\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns\n *   An assertion.\n */\nexport const convert =\n  /**\n   * @type {(\n   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return ok\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<string | Props | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\nfunction propsFactory(check) {\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node, ...parameters) {\n    return Boolean(\n      node &&\n        typeof node === 'object' &&\n        'type' in node &&\n        // @ts-expect-error: fine.\n        Boolean(check.call(this, node, ...parameters))\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n","/**\n * @param {string} d\n * @returns {string}\n */\nexport function color(d) {\n  return '\\u001B[33m' + d + '\\u001B[39m'\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\n/**\n * @typedef {boolean | 'skip'} Action\n *   Union of the action types.\n *\n * @typedef {number} Index\n *   Move to the sibling at `index` next (after node itself is completely\n *   traversed).\n *\n *   Useful if mutating the tree, such as removing the node the visitor is\n *   currently on, or any of its previous siblings.\n *   Results less than 0 or greater than or equal to `children.length` stop\n *   traversing the parent.\n *\n * @typedef {[(Action | null | undefined | void)?, (Index | null | undefined)?]} ActionTuple\n *   List with one or two values, the first an action, the second an index.\n *\n * @typedef {Action | ActionTuple | Index | null | undefined | void} VisitorResult\n *   Any value that can be returned from a visitor.\n */\n\n/**\n * @template {Node} [Visited=Node]\n *   Visited node type.\n * @template {Parent} [Ancestor=Parent]\n *   Ancestor type.\n * @callback Visitor\n *   Handle a node (matching `test`, if given).\n *\n *   Visitors are free to transform `node`.\n *   They can also transform the parent of node (the last of `ancestors`).\n *\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\n *   descendants to be walked (which is a bug).\n *\n *   When adding or removing previous siblings of `node` (or next siblings, in\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\n *   sibling to traverse after `node` is traversed.\n *   Adding or removing next siblings of `node` (or previous siblings, in case\n *   of reverse) is handled as expected without needing to return a new `Index`.\n *\n *   Removing the children property of an ancestor still results in them being\n *   traversed.\n * @param {Visited} node\n *   Found node.\n * @param {Array<Ancestor>} ancestors\n *   Ancestors of `node`.\n * @returns {VisitorResult}\n *   What to do next.\n *\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\n *   An `Action` is treated as a tuple of `[Action]`.\n *\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\n *   When the `Action` is `EXIT`, that action can be returned.\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   Tree type.\n * @template {Test} [Check=string]\n *   Test type.\n * @typedef {Visitor<import('./complex-types.js').Matches<import('./complex-types.js').InclusiveDescendant<Tree>, Check>, Extract<import('./complex-types.js').InclusiveDescendant<Tree>, Parent>>} BuildVisitor\n *   Build a typed `Visitor` function from a tree and a test.\n *\n *   It will infer which values are passed as `node` and which as `parents`.\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from './color.js'\n\n/**\n * Continue traversing as normal.\n */\nexport const CONTINUE = true\n\n/**\n * Stop traversing immediately.\n */\nexport const EXIT = false\n\n/**\n * Do not traverse this node’s children.\n */\nexport const SKIP = 'skip'\n\n/**\n * Visit nodes, with ancestral information.\n *\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\n *\n * You can choose for which nodes `visitor` is called by passing a `test`.\n * For complex tests, you should test yourself in `visitor`, as it will be\n * faster and will have improved type information.\n *\n * Walking the tree is an intensive task.\n * Make use of the return values of the visitor when possible.\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\n * to check if a node matches, and then perform different operations.\n *\n * You can change the tree.\n * See `Visitor` for more info.\n *\n * @param tree\n *   Tree to traverse.\n * @param test\n *   `unist-util-is`-compatible test\n * @param visitor\n *   Handle each node.\n * @param reverse\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\n * @returns\n *   Nothing.\n */\nexport const visitParents =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {Visitor<Node>} visitor\n     * @param {boolean | null | undefined} [reverse]\n     * @returns {void}\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        // @ts-expect-error no visitor given, so `visitor` is test.\n        visitor = test\n        test = null\n      }\n\n      const is = convert(test)\n      const step = reverse ? -1 : 1\n\n      factory(tree, undefined, [])()\n\n      /**\n       * @param {Node} node\n       * @param {number | undefined} index\n       * @param {Array<Parent>} parents\n       */\n      function factory(node, index, parents) {\n        /** @type {Record<string, unknown>} */\n        // @ts-expect-error: hush\n        const value = node && typeof node === 'object' ? node : {}\n\n        if (typeof value.type === 'string') {\n          const name =\n            // `hast`\n            typeof value.tagName === 'string'\n              ? value.tagName\n              : // `xast`\n              typeof value.name === 'string'\n              ? value.name\n              : undefined\n\n          Object.defineProperty(visit, 'name', {\n            value:\n              'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'\n          })\n        }\n\n        return visit\n\n        function visit() {\n          /** @type {ActionTuple} */\n          let result = []\n          /** @type {ActionTuple} */\n          let subresult\n          /** @type {number} */\n          let offset\n          /** @type {Array<Parent>} */\n          let grandparents\n\n          if (!test || is(node, index, parents[parents.length - 1] || null)) {\n            result = toResult(visitor(node, parents))\n\n            if (result[0] === EXIT) {\n              return result\n            }\n          }\n\n          // @ts-expect-error looks like a parent.\n          if (node.children && result[0] !== SKIP) {\n            // @ts-expect-error looks like a parent.\n            offset = (reverse ? node.children.length : -1) + step\n            // @ts-expect-error looks like a parent.\n            grandparents = parents.concat(node)\n\n            // @ts-expect-error looks like a parent.\n            while (offset > -1 && offset < node.children.length) {\n              // @ts-expect-error looks like a parent.\n              subresult = factory(node.children[offset], offset, grandparents)()\n\n              if (subresult[0] === EXIT) {\n                return subresult\n              }\n\n              offset =\n                typeof subresult[1] === 'number' ? subresult[1] : offset + step\n            }\n          }\n\n          return result\n        }\n      }\n    }\n  )\n\n/**\n * Turn a return value into a clean result.\n *\n * @param {VisitorResult} value\n *   Valid return values from visitors.\n * @returns {ActionTuple}\n *   Clean result.\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return [value]\n}\n","/**\n * @typedef {import('mdast').Parent} MdastParent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').Text} Text\n * @typedef {import('unist-util-visit-parents').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * @typedef {Content | Root} Node\n * @typedef {Extract<Node, MdastParent>} Parent\n * @typedef {Exclude<Parent, Root>} ContentParent\n *\n * @typedef RegExpMatchObject\n *   Info on the match.\n * @property {number} index\n *   The index of the search at which the result was found.\n * @property {string} input\n *   A copy of the search string in the text node.\n * @property {[Root, ...Array<ContentParent>, Text]} stack\n *   All ancestors of the text node, where the last node is the text itself.\n *\n * @callback ReplaceFunction\n *   Callback called when a search matches.\n * @param {...any} parameters\n *   The parameters are the result of corresponding search expression:\n *\n *   * `value` (`string`) — whole match\n *   * `...capture` (`Array<string>`) — matches from regex capture groups\n *   * `match` (`RegExpMatchObject`) — info on the match\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | undefined | null}\n *   Thing to replace with.\n *\n *   * when `null`, `undefined`, `''`, remove the match\n *   * …or when `false`, do not replace at all\n *   * …or when `string`, replace with a text node of that value\n *   * …or when `Node` or `Array<Node>`, replace with those nodes\n *\n * @typedef {string | RegExp} Find\n *   Pattern to find.\n *\n *   Strings are escaped and then turned into global expressions.\n *\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\n *   Several find and replaces, in array form.\n * @typedef {Record<string, Replace>} FindAndReplaceSchema\n *   Several find and replaces, in object form.\n * @typedef {[Find, Replace]} FindAndReplaceTuple\n *   Find and replace in tuple form.\n * @typedef {string | ReplaceFunction} Replace\n *   Thing to replace with.\n * @typedef {[RegExp, ReplaceFunction]} Pair\n *   Normalized find and replace.\n * @typedef {Array<Pair>} Pairs\n *   All find and replaced.\n *\n * @typedef Options\n *   Configuration.\n * @property {Test | null | undefined} [ignore]\n *   Test for which nodes to ignore.\n */\n\nimport escape from 'escape-string-regexp'\nimport {visitParents} from 'unist-util-visit-parents'\nimport {convert} from 'unist-util-is'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Find patterns in a tree and replace them.\n *\n * The algorithm searches the tree in *preorder* for complete values in `Text`\n * nodes.\n * Partial matches are not supported.\n *\n * @param tree\n *   Tree to change.\n * @param find\n *   Patterns to find.\n * @param replace\n *   Things to replace with (when `find` is `Find`) or configuration.\n * @param options\n *   Configuration (when `find` is not `Find`).\n * @returns\n *   Given, modified, tree.\n */\n// To do: next major: remove `find` & `replace` combo, remove schema.\nexport const findAndReplace =\n  /**\n   * @type {(\n   *   (<Tree extends Node>(tree: Tree, find: Find, replace?: Replace | null | undefined, options?: Options | null | undefined) => Tree) &\n   *   (<Tree extends Node>(tree: Tree, schema: FindAndReplaceSchema | FindAndReplaceList, options?: Options | null | undefined) => Tree)\n   * )}\n   **/\n  (\n    /**\n     * @template {Node} Tree\n     * @param {Tree} tree\n     * @param {Find | FindAndReplaceSchema | FindAndReplaceList} find\n     * @param {Replace | Options | null | undefined} [replace]\n     * @param {Options | null | undefined} [options]\n     * @returns {Tree}\n     */\n    function (tree, find, replace, options) {\n      /** @type {Options | null | undefined} */\n      let settings\n      /** @type {FindAndReplaceSchema|FindAndReplaceList} */\n      let schema\n\n      if (typeof find === 'string' || find instanceof RegExp) {\n        // @ts-expect-error don’t expect options twice.\n        schema = [[find, replace]]\n        settings = options\n      } else {\n        schema = find\n        // @ts-expect-error don’t expect replace twice.\n        settings = replace\n      }\n\n      if (!settings) {\n        settings = {}\n      }\n\n      const ignored = convert(settings.ignore || [])\n      const pairs = toPairs(schema)\n      let pairIndex = -1\n\n      while (++pairIndex < pairs.length) {\n        visitParents(tree, 'text', visitor)\n      }\n\n      // To do next major: don’t return the given tree.\n      return tree\n\n      /** @type {import('unist-util-visit-parents/complex-types.js').BuildVisitor<Root, 'text'>} */\n      function visitor(node, parents) {\n        let index = -1\n        /** @type {Parent | undefined} */\n        let grandparent\n\n        while (++index < parents.length) {\n          const parent = parents[index]\n\n          if (\n            ignored(\n              parent,\n              // @ts-expect-error: TS doesn’t understand but it’s perfect.\n              grandparent ? grandparent.children.indexOf(parent) : undefined,\n              grandparent\n            )\n          ) {\n            return\n          }\n\n          grandparent = parent\n        }\n\n        if (grandparent) {\n          return handler(node, parents)\n        }\n      }\n\n      /**\n       * Handle a text node which is not in an ignored parent.\n       *\n       * @param {Text} node\n       *   Text node.\n       * @param {Array<Parent>} parents\n       *   Parents.\n       * @returns {VisitorResult}\n       *   Result.\n       */\n      function handler(node, parents) {\n        const parent = parents[parents.length - 1]\n        const find = pairs[pairIndex][0]\n        const replace = pairs[pairIndex][1]\n        let start = 0\n        // @ts-expect-error: TS is wrong, some of these children can be text.\n        const index = parent.children.indexOf(node)\n        let change = false\n        /** @type {Array<PhrasingContent>} */\n        let nodes = []\n\n        find.lastIndex = 0\n\n        let match = find.exec(node.value)\n\n        while (match) {\n          const position = match.index\n          /** @type {RegExpMatchObject} */\n          const matchObject = {\n            index: match.index,\n            input: match.input,\n            // @ts-expect-error: stack is fine.\n            stack: [...parents, node]\n          }\n          let value = replace(...match, matchObject)\n\n          if (typeof value === 'string') {\n            value = value.length > 0 ? {type: 'text', value} : undefined\n          }\n\n          // It wasn’t a match after all.\n          if (value !== false) {\n            if (start !== position) {\n              nodes.push({\n                type: 'text',\n                value: node.value.slice(start, position)\n              })\n            }\n\n            if (Array.isArray(value)) {\n              nodes.push(...value)\n            } else if (value) {\n              nodes.push(value)\n            }\n\n            start = position + match[0].length\n            change = true\n          }\n\n          if (!find.global) {\n            break\n          }\n\n          match = find.exec(node.value)\n        }\n\n        if (change) {\n          if (start < node.value.length) {\n            nodes.push({type: 'text', value: node.value.slice(start)})\n          }\n\n          parent.children.splice(index, 1, ...nodes)\n        } else {\n          nodes = [node]\n        }\n\n        return index + nodes.length\n      }\n    }\n  )\n\n/**\n * Turn a schema into pairs.\n *\n * @param {FindAndReplaceSchema | FindAndReplaceList} schema\n *   Schema.\n * @returns {Pairs}\n *   Clean pairs.\n */\nfunction toPairs(schema) {\n  /** @type {Pairs} */\n  const result = []\n\n  if (typeof schema !== 'object') {\n    throw new TypeError('Expected array or object as schema')\n  }\n\n  if (Array.isArray(schema)) {\n    let index = -1\n\n    while (++index < schema.length) {\n      result.push([\n        toExpression(schema[index][0]),\n        toFunction(schema[index][1])\n      ])\n    }\n  } else {\n    /** @type {string} */\n    let key\n\n    for (key in schema) {\n      if (own.call(schema, key)) {\n        result.push([toExpression(key), toFunction(schema[key])])\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * Turn a find into an expression.\n *\n * @param {Find} find\n *   Find.\n * @returns {RegExp}\n *   Expression.\n */\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\n}\n\n/**\n * Turn a replace into a function.\n *\n * @param {Replace} replace\n *   Replace.\n * @returns {ReplaceFunction}\n *   Function.\n */\nfunction toFunction(replace) {\n  return typeof replace === 'function' ? replace : () => replace\n}\n","/**\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-find-and-replace').ReplaceFunction} ReplaceFunction\n */\n\n/**\n * @typedef {Content | Root} Node\n */\n\nimport {findAndReplace} from 'mdast-util-find-and-replace'\n\n/**\n * Turn normal line endings into hard breaks.\n *\n * @param {Node} tree\n *   Tree to change.\n * @returns {void}\n *   Nothing.\n */\nexport function newlineToBreak(tree) {\n  findAndReplace(tree, /\\r?\\n|\\r/g, replace)\n}\n\n/**\n * Replace line endings.\n *\n * @type {ReplaceFunction}\n */\nfunction replace() {\n  return {type: 'break'}\n}\n","/**\n * @typedef {import('mdast').Root} Root\n */\n\nimport {newlineToBreak} from 'mdast-util-newline-to-break'\n\n/**\n * Plugin to support hard breaks without needing spaces or escapes (turns enters\n * into `<br>`s).\n *\n * @type {import('unified').Plugin<void[], Root>}\n */\nexport default function remarkBreaks() {\n  return newlineToBreak\n}\n","import { markdownRenderer } from 'inkdrop'\nimport breaks from 'remark-breaks'\n\nmodule.exports = {\n  activate() {\n    return markdownRenderer.remarkPlugins.splice(0, 0, breaks)\n  },\n\n  deactivate() {\n    if (markdownRenderer) {\n      markdownRenderer.remarkPlugins = markdownRenderer.remarkPlugins.filter(\n        plugin => {\n          return plugin !== breaks\n        }\n      )\n    }\n  }\n}\n"],"names":["escapeStringRegexp","string","TypeError","replace","convert","test","undefined","ok","typeFactory","Array","isArray","anyFactory","propsFactory","castFactory","Error","tests","checks","index","length","any","parameters","call","check","all","node","key","type","assertion","Boolean","color","d","CONTINUE","EXIT","SKIP","visitParents","tree","visitor","reverse","is","step","factory","parents","value","name","tagName","Object","defineProperty","visit","result","subresult","offset","grandparents","toResult","children","concat","own","hasOwnProperty","findAndReplace","find","options","settings","schema","RegExp","ignored","ignore","pairs","toPairs","pairIndex","grandparent","parent","indexOf","handler","start","change","nodes","lastIndex","match","exec","position","matchObject","input","stack","push","slice","global","splice","toExpression","toFunction","escape","newlineToBreak","remarkBreaks","module","exports","activate","markdownRenderer","remarkPlugins","breaks","deactivate","filter","plugin"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}